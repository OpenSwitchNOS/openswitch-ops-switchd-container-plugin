From 2506103f95f79dde45d359b7b9292bde8b4ea3a4 Mon Sep 17 00:00:00 2001
From: Ricky Charlet <ricky.charlet@hpe.com>
Date: Mon, 28 Mar 2016 17:50:05 -0700
Subject: [PATCH] vxlan container POC. Initial checkin

This implements the container plugin of the vxlan POC. This
is a port of MyHanh's code. She originally made her code
work before the openvswitch 2.5 uprev. So this port differs
slightly.

Change-Id: I4aa54171e4bf1d97948e7796c2e63154c61e5594
Signed-off-by: Ricky Charlet <ricky.charlet@hpe.com>
---

diff --git a/include/netdev-vport-sim.h b/include/netdev-vport-sim.h
new file mode 100644
index 0000000..e8bd8f6
--- /dev/null
+++ b/include/netdev-vport-sim.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010, 2011, 2012, 2013 Nicira, Inc.
+ * Copyright (C) 2015 Hewlett-Packard Development Company, L.P.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NETDEV_VPORT_SIM_H
+#define NETDEV_VPORT_SIM_H 1
+
+#include <stdbool.h>
+#include <stddef.h>
+
+struct dpif_netlink_vport;
+struct dpif_flow_stats;
+struct netdev;
+struct netdev_class;
+struct netdev_stats;
+
+/* SIM provider API. */
+void netdev_vport_sim_register(void);
+void netdev_vport_patch_register(void);
+//extern int netdev_sim_get_hw_id(struct netdev *netdev);
+
+#endif /* netdev-sim.h */
diff --git a/src/netdev-sim.c b/src/netdev-sim.c
index 6c77028..ddfab2c 100644
--- a/src/netdev-sim.c
+++ b/src/netdev-sim.c
@@ -35,6 +35,7 @@
 #include "openvswitch/vlog.h"
 #include "netdev-sim.h"
 #include "ovs-atomic.h"
+#include "netdev-vport-sim.h"
 
 #define SWNS_EXEC       "/sbin/ip netns exec swns"
 
@@ -711,6 +712,8 @@
     netdev_register_provider(&sim_internal_class);
     netdev_register_provider(&sim_subinterface_class);
     netdev_register_provider(&sim_loopback_class);
+    netdev_vport_sim_register();
+
 }
 
 static void
diff --git a/src/netdev-vport-sim.c b/src/netdev-vport-sim.c
new file mode 100644
index 0000000..3cb6ce6
--- /dev/null
+++ b/src/netdev-vport-sim.c
@@ -0,0 +1,763 @@
+/*
+ * Copyright (c) 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015 Hewlett-Packard Development Company, L.P.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <config.h>
+
+#include "netdev-vport-sim.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+
+#include "byte-order.h"
+
+#include "daemon.h"
+#include "dirs.h"
+#include "dynamic-string.h"
+
+#include "hash.h"
+#include "hmap.h"
+#include "list.h"
+#include "netdev-provider.h"
+
+#include <openswitch-idl.h>
+#include "openvswitch/vlog.h"
+#include "shash.h"
+#include "socket-util.h"
+#include "unixctl.h"
+#include "util.h"
+
+VLOG_DEFINE_THIS_MODULE(netdev_vport);
+
+static struct vlog_rate_limit err_rl = VLOG_RATE_LIMIT_INIT(60, 5);
+
+#define GENEVE_DST_PORT 6081
+#define VXLAN_DST_PORT 4789
+#define LISP_DST_PORT 4341
+#define STT_DST_PORT 7471
+
+#define VXLAN_HLEN   (sizeof(struct udp_header) +         \
+                      sizeof(struct vxlanhdr))
+
+#define GENEVE_BASE_HLEN   (sizeof(struct udp_header) +         \
+                            sizeof(struct genevehdr))
+
+#define DEFAULT_TTL 64
+
+struct netdev_vport {
+    struct netdev up;
+
+    /* Protects all members below. */
+    struct ovs_mutex mutex;
+
+    struct eth_addr etheraddr;
+    struct netdev_stats stats;
+
+    /* Tunnels. */
+    struct netdev_tunnel_config tnl_cfg;
+    char egress_iface[IFNAMSIZ];
+    bool carrier_status;
+
+    /* Patch Ports. */
+    char *peer;
+    char linux_intf_name[16];
+    int link_state;
+    uint8_t hwaddr[ETH_ADDR_LEN] OVS_GUARDED;
+    char hw_addr_str[18];
+    //char *br_name;
+};
+
+struct vport_class {
+    const char *dpif_port;
+    struct netdev_class netdev_class;
+};
+
+/* Last read of the route-table's change number. */
+static uint64_t rt_change_seqno;
+
+static int netdev_vport_construct(struct netdev *);
+
+static int get_tunnel_config(const struct netdev *, struct smap *args);
+
+static uint16_t tnl_udp_port_min = 32768;
+static uint16_t tnl_udp_port_max = 61000;
+
+static bool
+is_vport_class(const struct netdev_class *class)
+{
+    return class->construct == netdev_vport_construct;
+}
+
+bool
+netdev_vport_is_vport_class(const struct netdev_class *class)
+{
+    return is_vport_class(class);
+}
+
+static const struct vport_class *
+vport_class_cast(const struct netdev_class *class)
+{
+    ovs_assert(is_vport_class(class));
+    return CONTAINER_OF(class, struct vport_class, netdev_class);
+}
+
+static struct netdev_vport *
+netdev_vport_cast(const struct netdev *netdev)
+{
+    ovs_assert(is_vport_class(netdev_get_class(netdev)));
+    return CONTAINER_OF(netdev, struct netdev_vport, up);
+}
+
+static const struct netdev_tunnel_config *
+get_netdev_tunnel_config(const struct netdev *netdev)
+{
+    return &netdev_vport_cast(netdev)->tnl_cfg;
+}
+
+
+static bool
+netdev_vport_needs_dst_port(const struct netdev *dev)
+{
+    const struct netdev_class *class = netdev_get_class(dev);
+    const char *type = netdev_get_type(dev);
+
+    return (class->get_config == get_tunnel_config &&
+            (!strcmp("geneve", type) || !strcmp("vxlan", type) ||
+             !strcmp("lisp", type) || !strcmp("stt", type)) );
+}
+
+
+
+/* Whenever the route-table change number is incremented,
+ * netdev_vport_route_changed() should be called to update
+ * the corresponding tunnel interface status. */
+
+static struct netdev *
+netdev_vport_alloc(void)
+{
+    struct netdev_vport *netdev = xzalloc(sizeof *netdev);
+    return &netdev->up;
+}
+
+static int
+netdev_vport_construct(struct netdev *netdev_)
+{
+    struct netdev_vport *dev = netdev_vport_cast(netdev_);
+    const char *type = netdev_get_type(netdev_);
+    VLOG_INFO("%s entered type %s", __FUNCTION__, type);
+    ovs_mutex_init(&dev->mutex);
+    eth_addr_random(&dev->etheraddr);
+
+    /* Add a default destination port for tunnel ports if none specified. */
+    if (!strcmp(type, "geneve")) {
+        dev->tnl_cfg.dst_port = htons(GENEVE_DST_PORT);
+    } else if (!strcmp(type, "vxlan")) {
+        dev->tnl_cfg.dst_port = htons(VXLAN_DST_PORT);
+    } else if (!strcmp(type, "lisp")) {
+        dev->tnl_cfg.dst_port = htons(LISP_DST_PORT);
+    } else if (!strcmp(type, "stt")) {
+        dev->tnl_cfg.dst_port = htons(STT_DST_PORT);
+    }
+
+    dev->tnl_cfg.dont_fragment = true;
+    dev->tnl_cfg.ttl = DEFAULT_TTL;
+    return 0;
+}
+
+static void
+netdev_vport_destruct(struct netdev *netdev_)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+    const char *devtype = netdev_get_type(netdev_);
+    VLOG_INFO("%s entered name %s type %s", __FUNCTION__, netdev_->name, devtype);
+    if(netdev->peer)
+       free(netdev->peer);
+    ovs_mutex_destroy(&netdev->mutex);
+}
+
+static void
+netdev_vport_dealloc(struct netdev *netdev_)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+    free(netdev);
+}
+
+
+static int
+netdev_vport_set_etheraddr(struct netdev *netdev_, const struct eth_addr mac)
+{
+/*	Don't want to be overwritten by the non-unique MAC
+    char mac_string[32];
+	char mac_str[32];
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+    ovs_mutex_lock(&netdev->mutex);
+    netdev->etheraddr = mac;
+    ovs_mutex_unlock(&netdev->mutex);
+    netdev_change_seq_changed(netdev_);
+
+    return 0;
+}
+
+static int
+netdev_vport_get_etheraddr(const struct netdev *netdev_, struct eth_addr *mac)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+    ovs_mutex_lock(&netdev->mutex);
+    *mac = netdev->etheraddr;
+    ovs_mutex_unlock(&netdev->mutex);
+
+    return 0;
+}
+
+
+
+static int
+tunnel_get_status(const struct netdev *netdev_, struct smap *smap)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+
+    if (netdev->egress_iface[0]) {
+        smap_add(smap, "tunnel_egress_iface", netdev->egress_iface);
+
+        smap_add(smap, "tunnel_egress_iface_carrier",
+                 netdev->carrier_status ? "up" : "down");
+    }
+    return 0;
+}
+
+static int
+netdev_vport_update_flags(struct netdev *netdev OVS_UNUSED,
+                          enum netdev_flags off,
+                          enum netdev_flags on OVS_UNUSED,
+                          enum netdev_flags *old_flagsp)
+{
+    if (off & (NETDEV_UP | NETDEV_PROMISC)) {
+        return EOPNOTSUPP;
+    }
+
+    *old_flagsp = NETDEV_UP | NETDEV_PROMISC;
+    return 0;
+}
+
+static void
+netdev_vport_run(void)
+{
+}
+
+static void
+netdev_vport_wait(void)
+{
+}
+
+static int
+netdev_vport_sim_set_hw_intf_info(struct netdev *netdev_, const struct smap *args)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(netdev_);
+    const char *mac_addr = smap_get(args, INTERFACE_HW_INTF_INFO_MAP_MAC_ADDR);
+    return 0;
+}
+
+/* Code specific to tunnel types. */
+
+static ovs_be64
+parse_key(const struct smap *args, const char *name,
+          bool *present, bool *flow)
+{
+    const char *s;
+
+    *present = false;
+    *flow = false;
+
+    s = smap_get(args, name);
+    if (!s) {
+        s = smap_get(args, "key");
+        if (!s) {
+            return 0;
+        }
+    }
+
+    *present = true;
+
+    if (!strcmp(s, "flow")) {
+        *flow = true;
+        return 0;
+    } else {
+        return htonll(strtoull(s, NULL, 0));
+    }
+}
+static bool
+tunnel_check_status_change__(struct netdev_vport *netdev)
+    OVS_REQUIRES(netdev->mutex)
+{
+
+    return false;
+}
+
+static int
+parse_tunnel_ip(const char *value, bool accept_mcast, bool *flow,
+                struct in6_addr *ipv6, uint16_t *protocol)
+{
+    if (!strcmp(value, "flow")) {
+        *flow = true;
+        *protocol = 0;
+        return 0;
+    }
+    if (addr_is_ipv6(value)) {
+        if (lookup_ipv6(value, ipv6)) {
+            return ENOENT;
+        }
+        if (!accept_mcast && ipv6_addr_is_multicast(ipv6)) {
+            return EINVAL;
+        }
+        *protocol = ETH_TYPE_IPV6;
+    } else {
+        struct in_addr ip;
+        if (lookup_ip(value, &ip)) {
+            return ENOENT;
+        }
+        if (!accept_mcast && ip_is_multicast(ip.s_addr)) {
+            return EINVAL;
+        }
+        in6_addr_set_mapped_ipv4(ipv6, ip.s_addr);
+        *protocol = ETH_TYPE_IP;
+    }
+    return 0;
+}
+
+
+static int
+set_tunnel_config(struct netdev *dev_, const struct smap *args)
+{
+    struct netdev_vport *dev = netdev_vport_cast(dev_);
+    const char *name = netdev_get_name(dev_);
+    const char *type = netdev_get_type(dev_);
+    bool ipsec_mech_set, needs_dst_port, has_csum;
+    uint16_t dst_proto = 0, src_proto = 0;
+    struct netdev_tunnel_config tnl_cfg;
+    struct smap_node *node;
+
+    has_csum = strstr(type, "gre") || strstr(type, "geneve") ||
+               strstr(type, "stt") || strstr(type, "vxlan");
+    ipsec_mech_set = false;
+    memset(&tnl_cfg, 0, sizeof tnl_cfg);
+
+    /* Add a default destination port for tunnel ports if none specified. */
+    if (!strcmp(type, "geneve")) {
+        tnl_cfg.dst_port = htons(GENEVE_DST_PORT);
+    }
+
+    if (!strcmp(type, "vxlan")) {
+        tnl_cfg.dst_port = htons(VXLAN_DST_PORT);
+    }
+
+    if (!strcmp(type, "lisp")) {
+        tnl_cfg.dst_port = htons(LISP_DST_PORT);
+    }
+
+    if (!strcmp(type, "stt")) {
+        tnl_cfg.dst_port = htons(STT_DST_PORT);
+    }
+
+    needs_dst_port = netdev_vport_needs_dst_port(dev_);
+    tnl_cfg.ipsec = strstr(type, "ipsec");
+    tnl_cfg.dont_fragment = true;
+
+    SMAP_FOR_EACH (node, args) {
+        if (!strcmp(node->key, "remote_ip")) {
+            VLOG_INFO("set_tunnel_config remote_IP %s",node->value);
+            int err;
+            err = parse_tunnel_ip(node->value, false, &tnl_cfg.ip_dst_flow,
+                                  &tnl_cfg.ipv6_dst, &dst_proto);
+            switch (err) {
+            case ENOENT:
+                VLOG_WARN("%s: bad %s 'remote_ip'", name, type);
+                break;
+            case EINVAL:
+                VLOG_WARN("%s: multicast remote_ip=%s not allowed",
+                          name, node->value);
+                return EINVAL;
+            } else {
+                tnl_cfg.ip_dst = in_addr.s_addr;
+            }
+        } else if (!strcmp(node->key, "local_ip")) {
+            int err;
+            err = parse_tunnel_ip(node->value, true, &tnl_cfg.ip_src_flow,
+                                  &tnl_cfg.ipv6_src, &src_proto);
+            switch (err) {
+            case ENOENT:
+                VLOG_WARN("%s: bad %s 'local_ip'", name, type);
+                break;
+            }
+        } else if (!strcmp(node->key, "tos")) {
+            if (!strcmp(node->value, "inherit")) {
+                tnl_cfg.tos_inherit = true;
+            } else {
+                char *endptr;
+                int tos;
+                tos = strtol(node->value, &endptr, 0);
+                if (*endptr == '\0' && tos == (tos & IP_DSCP_MASK)) {
+                    tnl_cfg.tos = tos;
+                } else {
+                    VLOG_WARN("%s: invalid TOS %s", name, node->value);
+                }
+            }
+        } else if (!strcmp(node->key, "ttl")) {
+            if (!strcmp(node->value, "inherit")) {
+                tnl_cfg.ttl_inherit = true;
+            } else {
+                tnl_cfg.ttl = atoi(node->value);
+            }
+        } else if (!strcmp(node->key, "dst_port") && needs_dst_port) {
+            tnl_cfg.dst_port = htons(atoi(node->value));
+        } else if (!strcmp(node->key, "csum") && has_csum) {
+            if (!strcmp(node->value, "true")) {
+                tnl_cfg.csum = true;
+            }
+        } else if (!strcmp(node->key, "df_default")) {
+            if (!strcmp(node->value, "false")) {
+                tnl_cfg.dont_fragment = false;
+            }
+        } else if (!strcmp(node->key, "peer_cert") && tnl_cfg.ipsec) {
+            if (smap_get(args, "certificate")) {
+                ipsec_mech_set = true;
+            } else {
+                const char *use_ssl_cert;
+
+                /* If the "use_ssl_cert" is true, then "certificate" and
+                 * "private_key" will be pulled from the SSL table.  The
+                 * use of this option is strongly discouraged, since it
+                 * will like be removed when multiple SSL configurations
+                 * are supported by OVS.
+                 */
+                use_ssl_cert = smap_get(args, "use_ssl_cert");
+                if (!use_ssl_cert || strcmp(use_ssl_cert, "true")) {
+                    VLOG_ERR("%s: 'peer_cert' requires 'certificate' argument",
+                             name);
+                    return EINVAL;
+                }
+                ipsec_mech_set = true;
+            }
+        } else if (!strcmp(node->key, "psk") && tnl_cfg.ipsec) {
+            ipsec_mech_set = true;
+        } else if (tnl_cfg.ipsec
+                && (!strcmp(node->key, "certificate")
+                    || !strcmp(node->key, "private_key")
+                    || !strcmp(node->key, "use_ssl_cert"))) {
+            /* Ignore options not used by the netdev. */
+        } else if (!strcmp(node->key, "key") ||
+                   !strcmp(node->key, "in_key") ||
+                   !strcmp(node->key, "out_key")) {
+            /* Handled separately below. */
+        } else {
+            VLOG_WARN("%s: unknown %s argument '%s'", name, type, node->key);
+        }
+    }
+
+    if (tnl_cfg.ipsec) {
+        static struct ovs_mutex mutex = OVS_MUTEX_INITIALIZER;
+        static pid_t pid = 0;
+
+#ifndef _WIN32
+        ovs_mutex_lock(&mutex);
+        if (pid <= 0) {
+            char *file_name = xasprintf("%s/%s", ovs_rundir(),
+                                        "ovs-monitor-ipsec.pid");
+            pid = read_pidfile(file_name);
+            free(file_name);
+        }
+        ovs_mutex_unlock(&mutex);
+#endif
+
+        if (pid < 0) {
+            VLOG_ERR("%s: IPsec requires the ovs-monitor-ipsec daemon",
+                     name);
+            return EINVAL;
+        }
+
+        if (smap_get(args, "peer_cert") && smap_get(args, "psk")) {
+            VLOG_ERR("%s: cannot define both 'peer_cert' and 'psk'", name);
+            return EINVAL;
+        }
+
+        if (!ipsec_mech_set) {
+            VLOG_ERR("%s: IPsec requires an 'peer_cert' or psk' argument",
+                     name);
+            return EINVAL;
+        }
+    }
+
+    if (!ipv6_addr_is_set(&tnl_cfg.ipv6_dst) && !tnl_cfg.ip_dst_flow) {
+        VLOG_ERR("%s: %s type requires valid 'remote_ip' argument",
+                 name, type);
+        return EINVAL;
+    }
+    if (tnl_cfg.ip_src_flow && !tnl_cfg.ip_dst_flow) {
+        VLOG_ERR("%s: %s type requires 'remote_ip=flow' with 'local_ip=flow'",
+                 name, type);
+        return EINVAL;
+    }
+    if (src_proto && dst_proto && src_proto != dst_proto) {
+        VLOG_ERR("%s: 'remote_ip' and 'local_ip' has to be of the same address family",
+                 name);
+        return EINVAL;
+    }
+    if (!tnl_cfg.ttl) {
+        tnl_cfg.ttl = DEFAULT_TTL;
+    }
+
+    tnl_cfg.in_key = parse_key(args, "in_key",
+                               &tnl_cfg.in_key_present,
+                               &tnl_cfg.in_key_flow);
+
+    tnl_cfg.out_key = parse_key(args, "out_key",
+                               &tnl_cfg.out_key_present,
+                               &tnl_cfg.out_key_flow);
+
+    ovs_mutex_lock(&dev->mutex);
+    if (memcmp(&dev->tnl_cfg, &tnl_cfg, sizeof tnl_cfg)) {
+        dev->tnl_cfg = tnl_cfg;
+        tunnel_check_status_change__(dev);
+        netdev_change_seq_changed(dev_);
+    }
+    ovs_mutex_unlock(&dev->mutex);
+
+    return 0;
+}
+
+
+static int
+get_tunnel_config(const struct netdev *dev, struct smap *args)
+{
+    struct netdev_vport *netdev = netdev_vport_cast(dev);
+    struct netdev_tunnel_config tnl_cfg;
+
+    ovs_mutex_lock(&netdev->mutex);
+    tnl_cfg = netdev->tnl_cfg;
+    ovs_mutex_unlock(&netdev->mutex);
+
+    if (ipv6_addr_is_set(&tnl_cfg.ipv6_dst)) {
+        smap_add_ipv6(args, "remote_ip", &tnl_cfg.ipv6_dst);
+    } else if (tnl_cfg.ip_dst_flow) {
+        smap_add(args, "remote_ip", "flow");
+    }
+
+    if (ipv6_addr_is_set(&tnl_cfg.ipv6_src)) {
+        smap_add_ipv6(args, "local_ip", &tnl_cfg.ipv6_src);
+    } else if (tnl_cfg.ip_src_flow) {
+        smap_add(args, "local_ip", "flow");
+    }
+
+    if (tnl_cfg.in_key_flow && tnl_cfg.out_key_flow) {
+        smap_add(args, "key", "flow");
+    } else if (tnl_cfg.in_key_present && tnl_cfg.out_key_present
+               && tnl_cfg.in_key == tnl_cfg.out_key) {
+        smap_add_format(args, "key", "%"PRIu64, ntohll(tnl_cfg.in_key));
+    } else {
+        if (tnl_cfg.in_key_flow) {
+            smap_add(args, "in_key", "flow");
+        } else if (tnl_cfg.in_key_present) {
+            smap_add_format(args, "in_key", "%"PRIu64,
+                            ntohll(tnl_cfg.in_key));
+        }
+
+        if (tnl_cfg.out_key_flow) {
+            smap_add(args, "out_key", "flow");
+        } else if (tnl_cfg.out_key_present) {
+            smap_add_format(args, "out_key", "%"PRIu64,
+                            ntohll(tnl_cfg.out_key));
+        }
+    }
+
+    if (tnl_cfg.ttl_inherit) {
+        smap_add(args, "ttl", "inherit");
+    } else if (tnl_cfg.ttl != DEFAULT_TTL) {
+        smap_add_format(args, "ttl", "%"PRIu8, tnl_cfg.ttl);
+    }
+
+    if (tnl_cfg.tos_inherit) {
+        smap_add(args, "tos", "inherit");
+    } else if (tnl_cfg.tos) {
+        smap_add_format(args, "tos", "0x%x", tnl_cfg.tos);
+    }
+
+    if (tnl_cfg.dst_port) {
+        uint16_t dst_port = ntohs(tnl_cfg.dst_port);
+        const char *type = netdev_get_type(dev);
+
+        if ((!strcmp("geneve", type) && dst_port != GENEVE_DST_PORT) ||
+            (!strcmp("vxlan", type) && dst_port != VXLAN_DST_PORT) ||
+            (!strcmp("lisp", type) && dst_port != LISP_DST_PORT) ||
+            (!strcmp("stt", type) && dst_port != STT_DST_PORT)) {
+            smap_add_format(args, "dst_port", "%d", dst_port);
+        }
+    }
+
+    if (tnl_cfg.csum) {
+        smap_add(args, "csum", "true");
+    }
+
+    if (!tnl_cfg.dont_fragment) {
+        smap_add(args, "df_default", "false");
+    }
+
+    return 0;
+}
+
+/* Code specific to patch ports. */
+
+
+static void
+netdev_vport_range(struct unixctl_conn *conn, int argc,
+                   const char *argv[], void *aux OVS_UNUSED)
+{
+    int val1, val2;
+
+    if (argc < 3) {
+        struct ds ds = DS_EMPTY_INITIALIZER;
+
+        ds_put_format(&ds, "Tunnel UDP source port range: %"PRIu16"-%"PRIu16"\n",
+                            tnl_udp_port_min, tnl_udp_port_max);
+
+        unixctl_command_reply(conn, ds_cstr(&ds));
+        ds_destroy(&ds);
+        return;
+    }
+
+    if (argc != 3) {
+        return;
+    }
+
+    val1 = atoi(argv[1]);
+    if (val1 <= 0 || val1 > UINT16_MAX) {
+        unixctl_command_reply(conn, "Invalid min.");
+        return;
+    }
+    val2 = atoi(argv[2]);
+    if (val2 <= 0 || val2 > UINT16_MAX) {
+        unixctl_command_reply(conn, "Invalid max.");
+        return;
+    }
+
+    if (val1 > val2) {
+        tnl_udp_port_min = val2;
+        tnl_udp_port_max = val1;
+    } else {
+        tnl_udp_port_min = val1;
+        tnl_udp_port_max = val2;
+    }
+    seq_change(tnl_conf_seq);
+
+    unixctl_command_reply(conn, "OK");
+}
+
+
+
+#define VPORT_FUNCTIONS(GET_CONFIG, SET_CONFIG,             \
+                        GET_TUNNEL_CONFIG, GET_STATUS,      \
+                        BUILD_HEADER,                       \
+                        PUSH_HEADER, POP_HEADER)            \
+    NULL,                                                   \
+    netdev_vport_run,                                       \
+    netdev_vport_wait,                                      \
+                                                            \
+    netdev_vport_alloc,                                     \
+    netdev_vport_construct,                                 \
+    netdev_vport_destruct,                                  \
+    netdev_vport_dealloc,                                   \
+    GET_CONFIG,                                             \
+    SET_CONFIG,                                             \
+    NULL,                      \
+    NULL,           /* set_hw_intf_config */    \
+    GET_TUNNEL_CONFIG,                                      \
+    BUILD_HEADER,                                           \
+    PUSH_HEADER,                                            \
+    POP_HEADER,                                             \
+    NULL,                       /* get_numa_id */           \
+    NULL,                       /* set_multiq */            \
+                                                            \
+    NULL,                       /* send */                  \
+    NULL,                       /* send_wait */             \
+    netdev_vport_set_etheraddr,                             \
+    netdev_vport_get_etheraddr,                             \
+    NULL,                       /* get_mtu */               \
+    NULL,                       /* set_mtu */               \
+    NULL,                       /* get_ifindex */           \
+    NULL,                       /* get_carrier */           \
+    NULL,                       /* get_carrier_resets */    \
+    NULL,                       /* get_miimon */            \
+    NULL,                                                   \
+                                                            \
+    NULL,                       /* get_features */          \
+    NULL,                       /* set_advertisements */    \
+                                                            \
+    NULL,                       /* set_policing */          \
+    NULL,                       /* get_qos_types */         \
+    NULL,                       /* get_qos_capabilities */  \
+    NULL,                       /* get_qos */               \
+    NULL,                       /* set_qos */               \
+    NULL,                       /* get_queue */             \
+    NULL,                       /* set_queue */             \
+    NULL,                       /* delete_queue */          \
+    NULL,                       /* get_queue_stats */       \
+    NULL,                       /* queue_dump_start */      \
+    NULL,                       /* queue_dump_next */       \
+    NULL,                       /* queue_dump_done */       \
+    NULL,                       /* dump_queue_stats */      \
+                                                            \
+    NULL,                       /* get_in4 */               \
+    NULL,                       /* set_in4 */               \
+    NULL,                       /* get_in6 */               \
+    NULL,                       /* add_router */            \
+    NULL,                       /* get_next_hop */          \
+    GET_STATUS,                                             \
+    NULL,                       /* arp_lookup */            \
+                                                            \
+    netdev_vport_update_flags,                              \
+                                                            \
+    NULL,                   /* rx_alloc */                  \
+    NULL,                   /* rx_construct */              \
+    NULL,                   /* rx_destruct */               \
+    NULL,                   /* rx_dealloc */                \
+    NULL,                   /* rx_recv */                   \
+    NULL,                   /* rx_wait */                   \
+    NULL,                   /* rx_drain */
+
+
+#define TUNNEL_CLASS(NAME, DPIF_PORT, BUILD_HEADER, PUSH_HEADER, POP_HEADER)   \
+    { DPIF_PORT,                                                               \
+        { NAME, VPORT_FUNCTIONS(get_tunnel_config,                             \
+                                set_tunnel_config,                             \
+                                get_netdev_tunnel_config,                      \
+                                tunnel_get_status,                             \
+                                BUILD_HEADER, PUSH_HEADER, POP_HEADER) }}
+
+void
+netdev_vport_sim_register(void)
+{
+    /* The name of the dpif_port should be short enough to accomodate adding
+     * a port number to the end if one is necessary. */
+    static const struct vport_class vport_classes =
+        TUNNEL_CLASS("vxlan", "vxlan_sys", NULL,NULL,NULL);
+
+    netdev_register_provider(&vport_classes.netdev_class);
+    unixctl_command_register("tnl/egress_port_range", "min max", 0, 2,
+                                 netdev_vport_range, NULL);
+}
diff --git a/src/ofproto-sim-provider.c b/src/ofproto-sim-provider.c
index 74c2d70..20249f6 100644
--- a/src/ofproto-sim-provider.c
+++ b/src/ofproto-sim-provider.c
@@ -34,6 +34,8 @@
 #include "openvswitch/vlog.h"
 #include "ofproto-sim-provider.h"
 #include "vswitch-idl.h"
+#include "netdev-vport-sim.h"
+#include "netinet/in.h"
 
 VLOG_DEFINE_THIS_MODULE(ofproto_provider_sim);
 
@@ -112,6 +114,9 @@
     if (port_type && (strcmp(port_type, OVSREC_INTERFACE_TYPE_LOOPBACK) == 0)) {
             return port_type;
     }
+    if (port_type && (strcmp(port_type, OVSREC_INTERFACE_TYPE_VXLAN) == 0)) {
+            return port_type;
+    }
     return "system";
 }
 
@@ -145,7 +150,7 @@
      * name in ASIC OVS. In ASIC OVS creating a bridge also creates a bundle &
      * port with the same name. The port will be 'internal' type. */
     if (strcmp(ofproto_->type, "system") == 0) {
-
+/* RICKY: FIXME  Do we need to pass "datapath_type=netdev" in the command args? */
         snprintf(cmd_str, MAX_CMD_LEN, "%s --may-exist add-br %s -- set bridge %s datapath_type=netdev",
                  OVS_VSCTL, ofproto->up.name, ofproto->up.name);
         if (system(cmd_str) != 0) {
@@ -292,6 +297,22 @@
 static void
 port_destruct(struct ofport *port_ OVS_UNUSED)
 {
+	struct sim_provider_ofport *port = sim_provider_ofport_cast(port_);
+    const char *devname = netdev_get_name(port->up.netdev);
+    const char *devtype = netdev_get_type(port->up.netdev);
+    const char *br_name = port->up.ofproto->name;
+    int error = 0;
+    char cmd_str[MAX_CMD_LEN];
+
+    if(!strcmp(devtype,"vxlan") )
+    {
+      snprintf(cmd_str, MAX_CMD_LEN, "%s del-port %s %s", OVS_VSCTL,br_name,devname);
+      if(system(cmd_str) != 0)
+      {
+        VLOG_ERR("ERROR %s can't exec cmd %s error %s", __FUNCTION__, cmd_str, strerror(errno));
+        error = 1;
+      }
+    }
     return;
 }
 
@@ -966,12 +987,62 @@
     return ENODEV;
 
 }
+static int
+port_sim_add( struct netdev *netdev, char *br)
+{
+    int error = 0;
+    char cmd_str[MAX_CMD_LEN];
+    struct eth_addr *mac;
+    char mac_string[32];
+    const char *devname = netdev_get_name(netdev);
+    const char *devtype = netdev_get_type(netdev);
 
+    if(!strcmp(devtype,"vxlan")) {
+        const struct netdev_tunnel_config *tnl_cfg = netdev_get_tunnel_config(netdev);
+        if (tnl_cfg) {
+            char buf[INET_ADDRSTRLEN];
+            ovs_be32 ip_dst = in6_addr_get_mapped_ipv4(&tnl_cfg->ipv6_dst);
+            inet_ntop (AF_INET, &ip_dst, buf, INET_ADDRSTRLEN);
+            snprintf(cmd_str, MAX_CMD_LEN, "%s add-port %s %s "
+                 "-- set interface %s type=%s option:remote_ip=%s option:key=flow ofport_request=10",
+                 OVS_VSCTL, br, devname, devname,devtype,buf);
+            if (system(cmd_str) != 0) {
+               VLOG_ERR("Failed to add port in ASIC OVS. cmd=%s, rc=%s",
+                 cmd_str, strerror(errno));
+               error = 1;
+            }
+        }
+
+       error = netdev_get_etheraddr(netdev, mac);
+       if (!error) {
+           sprintf(mac_string, ETH_ADDR_FMT, mac->ea );
+           VLOG_INFO("%s mac_address %s ",__FUNCTION__, mac_string);
+
+       }
+
+       sprintf(cmd_str, "%s /sbin/ip link set %s address %s",
+               SWNS_EXEC, devname, mac_string);
+       if (system(cmd_str) != 0) {
+           VLOG_ERR("NETDEV-SIM | system command failure cmd=%s", cmd_str);
+       }
+       snprintf(cmd_str, MAX_CMD_LEN, "%s /sbin/ip link set dev %s up",
+                SWNS_EXEC, devname);
+       if (system(cmd_str) != 0) {
+           VLOG_ERR("Failed to set link state. cmd=%s, rc=%s", cmd_str,
+                    strerror(errno));
+           error = 1;
+       }
+
+    }
+}
 static int
 port_add(struct ofproto *ofproto_, struct netdev *netdev)
 {
     struct sim_provider_node *ofproto = sim_provider_node_cast(ofproto_);
     const char *devname = netdev_get_name(netdev);
+    const char *devtype = netdev_get_type(netdev);
+    VLOG_INFO("VXLAN_POC %s port_add devname %s, %s , %s ",__FUNCTION__, devname, ofproto->up.name, devtype) ;
+    port_sim_add(netdev, ofproto->up.name);
 
     sset_add(&ofproto->ports, devname);
     return 0;
diff --git a/tests/test_switchd_container_ct_vxlan.py b/tests/test_switchd_container_ct_vxlan.py
new file mode 100644
index 0000000..b214ade
--- /dev/null
+++ b/tests/test_switchd_container_ct_vxlan.py
@@ -0,0 +1,177 @@
+#!/usr/bin/python
+#
+# (c) Copyright 2015 Hewlett Packard Enterprise Development LP
+#
+# Licensed under the Apache License, Version 2.0 (the "License"); you may
+# not use this file except in compliance with the License. You may obtain
+# a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+# License for the specific language governing permissions and limitations
+# under the License.
+
+import pytest
+from opsvsi.docker import *
+from opsvsi.opsvsitest import *
+from opsvsiutils.systemutil import *
+
+OVS_VSCTL="/opt/openvswitch/bin/ovs-vsctl"
+OPS_VSCTL="/usr/bin/ovs-vsctl"
+OVS_OFCTL="/opt/openvswitch/bin/ovs-ofctl"
+OVS_ADDFLOW="/opt/openvswitch/bin/ovs-ofctl add-flow"
+OVS_APPCTL="/opt/openvswitch/bin/ovs-appctl"
+HOST_PER_SW = 2
+NUM_OF_SWS  = 2
+SWNS_EXE = "ip netns exec swns "
+
+HOSTMAC=["notused","00:00:00:00:aa:01","00:00:00:00:aa:02", "00:00:00:00:aa:01","00:00:00:00:aa:02",]
+SW_ROUTERIP=["9.0.1.1", "9.0.2.2"]
+
+
+#  2 hosts per switch
+#  2 switches
+
+
+class mytopo(Topo):
+    def build(self, hsts=2, sws=2, **_opts):
+        self.hsts = hsts*sws
+        self.sws  = sws
+        # Create Hosts
+        tot_host= sws * hsts
+        for h in irange(1,tot_host):
+           host = self.addHost("h%s" % h, mac="%s" % HOSTMAC[h])
+
+        # Create Switch
+        for s in irange(1, sws):
+           sw = self.addSwitch("s%s" % s)
+        '''
+        for s in irange(1, sws):
+           sw = self.addSwitch("s%s" % s)
+           for h in irange(1, hsts):
+              host = self.addHost("h%s-s%s" % (h,s)
+        '''
+        # Create Links between host and switch
+
+        self.addLink('h1', 's1')
+        self.addLink('h2', 's2')
+        self.addLink('h3', 's1')
+        self.addLink('h4', 's2')
+        self.addLink('s1', 's2')
+
+class vlanTagTest( OpsVsiTest ):
+
+    def setupNet(self):
+        host_opts = self.getHostOpts()
+        switch_opts = self.getSwitchOpts()
+        vxlan_topo = mytopo(hsts=HOST_PER_SW, sws=NUM_OF_SWS, hopts=host_opts, sopts=switch_opts)
+        self.net = Mininet(vxlan_topo, switch=VsiOpenSwitch,
+                           host=Host, link=OpsVsiLink,
+                           controller=None, build=True)
+
+    def vtep_setup(self,ip1,ip2):
+        info("\n ### vtep_setup remote_ip for s1 %s for s2 %s ###\n" % (ip1,ip2))
+        s1 = self.net.switches[ 0 ]
+        s2 = self.net.switches[ 1 ]
+        s1.ovscmd(OPS_VSCTL + " add-port bridge_normal vtep -- set interface vtep type=vxlan option:remote_ip=%s" % ip1)
+        sleep(1)
+        s2.ovscmd(OPS_VSCTL + " add-port bridge_normal vtep -- set interface vtep type=vxlan option:remote_ip=%s" % ip2)
+        '''
+        ops = s2.ovscmd(OPS_VSCTL + " show")
+        ovs = s2.ovscmd(OVS_VSCTL + " show")
+        info("\n \n ops-ctl \n %s \n\n ovs-ctl \n%s \n\n" % (ops, ovs))
+        '''
+
+    def conf_access_port(self, intf, vlan):
+        info("\n ### Access_ports setup ### \n")
+        nsw = 0
+        for sw in self.net.switches:
+            sw.cmdCLI("configure terminal")
+            sw.cmdCLI("vlan %s" % vlan)
+            sw.cmdCLI("no shutdown")
+            sw.cmdCLI("end")
+            sleep(1)
+            sw.cmdCLI("configure terminal")
+            sw.cmdCLI("interface %s" % intf)
+            sw.cmdCLI("no routing")
+            sw.cmdCLI("vlan access %s" % vlan)
+            sw.cmdCLI("no shutdown")
+            sw.cmdCLI("end")
+            nsw += 1
+
+
+    def conf_net_port(self, intf):
+       info("\n ### route_conf for interface %s" % intf)
+       nsw = 0
+       for sw in self.net.switches:
+           sw.cmdCLI("configure terminal")
+           sw.cmdCLI("interface %s" % intf)
+           sw.cmdCLI("no shutdown")
+           sw.cmdCLI("ip address %s/24" % SW_ROUTERIP[nsw])
+           sw.cmdCLI("no shutdown")
+           sw.cmdCLI("exit")
+           nsw += 1
+           sleep(1)
+       sleep(5)
+       s1 = self.net.switches[ 0 ]
+       s2 = self.net.switches[ 1 ]
+       info("\nRouting switch s1\n")
+       s1.ovscmd(SWNS_EXE + "route add -net 9.0.2.0/24 gw 9.0.1.1 dev %s" % intf)
+       sleep(1)
+       out = s1.ovscmd(SWNS_EXE + "route -n")
+       info("result %s" % out)
+       info("\nRouting switch s2\n")
+       s2.ovscmd(SWNS_EXE + "route add -net 9.0.1.0/24 gw 9.0.2.2 dev %s" % intf)
+       sleep(1)
+       out = s2.ovscmd(SWNS_EXE + "route -n")
+       info("result %s" % out)
+
+
+    def tcpdump_setup(self):
+        info("\n ### tcpdump setup ### \n")
+        for sw in self.net.switches:
+            sw.ovscmd("mv /usr/sbin/tcpdump /usr/bin/")
+            out = sw.ovscmd("which tcpdump")
+            if "usr/bin/tcpdump" not in out:
+               info("Failed to set up tcpdump")
+
+    def test_ping(self):
+        h1 = self.net.hosts[0]
+        h2 = self.net.hosts[1]
+        info("\nh1 ip is %s\nh2 ip is %s\n" % (h1.IP(), h2.IP()))
+        out = h1.cmd("ping -c 3 %s" % h2.IP())
+        status = parsePing(out)
+        if status:
+            info("\n **** h1 - h2 Ping success! *****\n")
+        else:
+            info("\n h1- h2 Ping failed!\n")
+
+    def vxlan(self):
+        info("\n\n\n ########## testing vxlan ##########\n\n\n")
+        self.vtep_setup(SW_ROUTERIP[1], SW_ROUTERIP[0])
+        self.tcpdump_setup()
+        self.conf_access_port("1", "100")
+        self.conf_net_port("3")
+        self.test_ping()
+
+@pytest.mark.timeout(0)
+class Test_switchd_container_vlan_access:
+
+    def setup_class(cls):
+        Test_switchd_container_vlan_access.test = vlanTagTest()
+
+    # TC_1
+    def test_switchd_container_check_config(self):
+        self.test.vxlan()
+        CLI(self.test.net)
+
+    def teardown_class(cls):
+        # Stop the Docker containers, and
+        # mininet topology
+        Test_switchd_container_vlan_access.test.net.stop()
+
+    def __del__(self):
+        del self.test

